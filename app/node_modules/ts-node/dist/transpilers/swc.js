"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSwcOptions = exports.targetMapping = exports.create = void 0;
const ts_internals_1 = require("../ts-internals");
function create(createOptions) {
    const { swc, service: { config, projectLocalResolveHelper }, transpilerConfigLocalResolveHelper, nodeModuleEmitKind, } = createOptions;
    // Load swc compiler
    let swcInstance;
    // Used later in diagnostics; merely needs to be human-readable.
    let swcDepName = 'swc';
    if (typeof swc === 'string') {
        swcDepName = swc;
        swcInstance = require(transpilerConfigLocalResolveHelper(swc, true));
    }
    else if (swc == null) {
        let swcResolved;
        try {
            swcDepName = '@swc/core';
            swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);
        }
        catch (e) {
            try {
                swcDepName = '@swc/wasm';
                swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);
            }
            catch (e) {
                throw new Error('swc compiler requires either @swc/core or @swc/wasm to be installed as a dependency.  See https://typestrong.org/ts-node/docs/transpilers');
            }
        }
        swcInstance = require(swcResolved);
    }
    else {
        swcInstance = swc;
    }
    // Prepare SWC options derived from typescript compiler options
    const { nonTsxOptions, tsxOptions } = createSwcOptions(config.options, nodeModuleEmitKind, swcInstance, swcDepName);
    const transpile = (input, transpileOptions) => {
        const { fileName } = transpileOptions;
        const swcOptions = fileName.endsWith('.tsx') || fileName.endsWith('.jsx') ? tsxOptions : nonTsxOptions;
        const { code, map } = swcInstance.transformSync(input, {
            ...swcOptions,
            filename: fileName,
        });
        return { outputText: code, sourceMapText: map };
    };
    return {
        transpile,
    };
}
exports.create = create;
